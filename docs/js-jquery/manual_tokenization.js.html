<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>manual_tokenization.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="concrete.html">concrete</a></li><li></li><li><a href="concrete.util.html">util</a><ul class='methods'><li data-type='method'><a href="concrete.util.html#.generateUUID">generateUUID</a></li><li data-type='method'><a href="concrete.util.html#.generateUUIDString">generateUUIDString</a></li><li data-type='method'><a href="concrete.util.html#.getURLParameter">getURLParameter</a></li></ul></li><li><a href="concrete.widget.html">widget</a><ul class='methods'><li data-type='method'><a href="concrete.widget.html#.createCommunicationDiv">createCommunicationDiv</a></li><li data-type='method'><a href="concrete.widget.html#.createSectionDiv">createSectionDiv</a></li><li data-type='method'><a href="concrete.widget.html#.createSentenceDiv">createSentenceDiv</a></li><li data-type='method'><a href="concrete.widget.html#.createTokenizationDiv">createTokenizationDiv</a></li><li data-type='method'><a href="concrete.widget.html#.getSelectedTokenRefSequences">getSelectedTokenRefSequences</a></li><li data-type='method'><a href="concrete.widget.html#.getTokenRefSequenceForTokenObject">getTokenRefSequenceForTokenObject</a></li><li data-type='method'><a href="concrete.widget.html#.getTokenRefSequenceForTokensMatchingSelector">getTokenRefSequenceForTokensMatchingSelector</a></li></ul></li></ul><h3>Classes</h3><ul><li><a href="Communication.html">Communication</a><ul class='methods'><li data-type='method'><a href="Communication.html#addInternalReferences">addInternalReferences</a></li><li data-type='method'><a href="Communication.html#getEntityForEntityMentionUUID">getEntityForEntityMentionUUID</a></li><li data-type='method'><a href="Communication.html#getEntityMentionSetWithToolname">getEntityMentionSetWithToolname</a></li><li data-type='method'><a href="Communication.html#getEntityMentionWithUUID">getEntityMentionWithUUID</a></li><li data-type='method'><a href="Communication.html#getEntityWithEntityId">getEntityWithEntityId</a></li><li data-type='method'><a href="Communication.html#getFirstSentence">getFirstSentence</a></li><li data-type='method'><a href="Communication.html#getFirstTokenization">getFirstTokenization</a></li><li data-type='method'><a href="Communication.html#getSectionsAsList">getSectionsAsList</a></li><li data-type='method'><a href="Communication.html#getSentencesAsList">getSentencesAsList</a></li><li data-type='method'><a href="Communication.html#getSentenceWithUUID">getSentenceWithUUID</a></li><li data-type='method'><a href="Communication.html#getSituationMentionWithUUID">getSituationMentionWithUUID</a></li><li data-type='method'><a href="Communication.html#getTokenizationsAsList">getTokenizationsAsList</a></li><li data-type='method'><a href="Communication.html#getTokenizationWithUUID">getTokenizationWithUUID</a></li><li data-type='method'><a href="Communication.html#getTokensForEntityMentionID">getTokensForEntityMentionID</a></li><li data-type='method'><a href="Communication.html#initFromTJSONProtocolObject">initFromTJSONProtocolObject</a></li><li data-type='method'><a href="Communication.html#initFromTJSONProtocolString">initFromTJSONProtocolString</a></li><li data-type='method'><a href="Communication.html#toTJSONProtocolObject">toTJSONProtocolObject</a></li><li data-type='method'><a href="Communication.html#toTJSONProtocolString">toTJSONProtocolString</a></li></ul></li><li><a href="Tokenization.html">Tokenization</a><ul class='methods'><li data-type='method'><a href="Tokenization.html#addTokenTagging">addTokenTagging</a></li><li data-type='method'><a href="Tokenization.html#getTokenTaggingsOfType">getTokenTaggingsOfType</a></li></ul></li><li><a href="TokenTagging.html">TokenTagging</a><ul class='methods'><li data-type='method'><a href="TokenTagging.html#.create">create</a></li><li data-type='method'><a href="TokenTagging.html#bioGetBIOValue">bioGetBIOValue</a></li><li data-type='method'><a href="TokenTagging.html#bioGetTagSeparator">bioGetTagSeparator</a></li><li data-type='method'><a href="TokenTagging.html#bioGetTagValue">bioGetTagValue</a></li><li data-type='method'><a href="TokenTagging.html#bioGetTokenIndexForB">bioGetTokenIndexForB</a></li><li data-type='method'><a href="TokenTagging.html#bioSetTaggedTokenTag">bioSetTaggedTokenTag</a></li><li data-type='method'><a href="TokenTagging.html#bioSetTagSeparator">bioSetTagSeparator</a></li><li data-type='method'><a href="TokenTagging.html#deepCopyTaggedTokenList">deepCopyTaggedTokenList</a></li><li data-type='method'><a href="TokenTagging.html#getTaggedTokenWithTokenIndex">getTaggedTokenWithTokenIndex</a></li><li data-type='method'><a href="TokenTagging.html#setAllTaggedTokenTags">setAllTaggedTokenTags</a></li><li data-type='method'><a href="TokenTagging.html#setTaggedTokenTag">setTaggedTokenTag</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-_jQuery.fn_.html">jQuery.fn</a><ul class='methods'><li data-type='method'><a href="external-_jQuery.fn_.html#.addAllEntitiesInCommunication">addAllEntitiesInCommunication</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.addAllEntityMentionsInCommunication">addAllEntityMentionsInCommunication</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.addEntityMention">addEntityMention</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.addEntityMentionSet">addEntityMentionSet</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.communicationWidget">communicationWidget</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.enableTokenClickCallbacks">enableTokenClickCallbacks</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.enableTokenSelectCallbacks">enableTokenSelectCallbacks</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getEntityMentionElements">getEntityMentionElements</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getManualTokenization">getManualTokenization</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getSentenceElements">getSentenceElements</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getTokenClickCallbacks">getTokenClickCallbacks</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getTokenElements">getTokenElements</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getTokenElementsWithIndex">getTokenElementsWithIndex</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getTokenElementsWithMatchingTag">getTokenElementsWithMatchingTag</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getTokenizationElements">getTokenizationElements</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getTokenPaddingElementsWithIndex">getTokenPaddingElementsWithIndex</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getTokenRefSequenceElements">getTokenRefSequenceElements</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getTokenRefSequenceForTokensMatchingSelector">getTokenRefSequenceForTokensMatchingSelector</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.getTokenSelectCallbacks">getTokenSelectCallbacks</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.manualTokenizationWidget">manualTokenizationWidget</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.sectionWidget">sectionWidget</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.sentenceWidget">sentenceWidget</a></li><li data-type='method'><a href="external-_jQuery.fn_.html#.tokenizationWidget">tokenizationWidget</a></li></ul></li><li><a href="external-jQuery_Object.html">jQuery_Object</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">manual_tokenization.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Creates a Tokenization for a manualTokenizationWidget
 *
 * The {@link external:"jQuery.fn".manualTokenizationWidget jQuery.fn.manualTokenizationWidget}
 * function creates a UI widget that allows a user to specify
 * token boundaries between characters.  This function creates
 * a Tokenization object based on the token boundaries currently
 * shown in the UI.
 *
 * This function should be called on the same jQuery element
 * that {@link external:"jQuery.fn".manualTokenizationWidget jQuery.fn.manualTokenizationWidget}
 * was called on.
 *
 * @returns {Tokenization}
 *
 * @function external:"jQuery.fn".getManualTokenization
 */
$.fn.getManualTokenization = function() {
  var tokenizeSentenceDiv;
  if (this.hasClass('manual_tokenization')) {
    tokenizeSentenceDiv = this;
  }
  else {
    tokenizeSentenceDiv = this.find('.manual_tokenization').first();
  }
  var sentence = tokenizeSentenceDiv.data('sentence');

  var joinedTokenIndices = [];
  tokenizeSentenceDiv.find('.concrete_character_gap.connected_concrete_characters').each(function() {
    joinedTokenIndices.push($(this).data('tokenIndex'));
  });

  var tokenization = new Tokenization();
  tokenization.kind = TokenizationKind.TOKEN_LIST;
  tokenization.metadata = new AnnotationMetadata();
  tokenization.metadata.timestamp = Math.floor(Date.now()/1000);
  tokenization.metadata.tool = 'concrete.js - getManualTokenization()';
  tokenization.tokenList = new TokenList();
  tokenization.tokenList.tokenList = [];
  tokenization.uuid = concrete.util.generateUUID();

  for (var i = sentence.textSpan.start; i &lt; sentence.textSpan.ending-1; i++) {
    var textSpan = new TextSpan();
    textSpan.start = i;
    while (joinedTokenIndices.includes(i)) {
      i += 1;
    }
    textSpan.ending = i+1;
    var token = new Token();
    token.text = sentence.section.comm.text.substring(textSpan.start, textSpan.ending);
    token.textSpan = textSpan;
    token.tokenIndex = tokenization.tokenList.tokenList.length;

    // Don't create Tokens if the text field contains only whitespace
    if (token.text.trim().length !== 0) {
      tokenization.tokenList.tokenList.push(token);
    }
  }

  return tokenization;
};


/**
 * UI widget for manual tokenization of a Concrete Sentence
 *
 * Takes a Sentence, creates DOM structure for characters in
 * Sentence, attaches event handlers for keyboard input and
 * navigation.  When the widget is first created, each character
 * is treated as a separate token.  The 'x' key can be used
 * to connect/disconnect characters, and the arrow keys used
 * to navigate between characters.
 *
 * Use {@link external:"jQuery.fn".getManualTokenization jQuery.fn.getManualTokenization}
 * to get a Tokenization object reflecting the current token
 * boundaries shown in the UI.
 *
 * This function attaches a div to the jQuery element with
 * the structure:
 *
 * ```
 * &lt;div class="manual_tokenization">
 *   &lt;span class="concrete_character">A&lt;/span>
 *   &lt;span class="concrete_character_gap">&amp;nbsp; &lt;/span>
 *   &lt;span class="concrete_character">B&lt;/span>
 *   &lt;span class="concrete_character_gap">&amp;nbsp; &lt;/span>
 *   &lt;span class="concrete_character">C&lt;/span>
 *   &lt;span class="concrete_character_gap">&amp;nbsp; &lt;/span>
 *   ...
 *   &lt;span class="concrete_character">Z&lt;/span>
 * &lt;/div>
 * ```
 *
 * When the user uses the UI to "connect" two characters into
 * a single token, the .concrete_connected_character_class will
 * be added to the .concrete_character spans for the two
 * characters and the .concrete_character_gap span between the
 * character spans.
 *
 * Using the DOM structure shown above, if the character spans
 * for 'A' and 'B' were connected, the new DOM structure would be:
 *
 * ```
 * &lt;div class="manual_tokenization">
 *   &lt;span class="concrete_character connected_concrete_characters">A&lt;/span>
 *   &lt;span class="concrete_character_gap connected_concrete_characters">&amp;nbsp; &lt;/span>
 *   &lt;span class="concrete_character connected_concrete_characters">B&lt;/span>
 *   &lt;span class="concrete_character_gap">&amp;nbsp; &lt;/span>
 *   &lt;span class="concrete_character">C&lt;/span>
 *   &lt;span class="concrete_character_gap">&amp;nbsp; &lt;/span>
 *   ...
 *   &lt;span class="concrete_character">Z&lt;/span>
 * &lt;/div>
 * ```
 *
 * This function does not set any CSS properties on the elements
 * it creates.  Here is some suggested CSS styling:
 *
 * ```
 *   .concrete_character {
 *     display: inline-block;
 *     border-bottom: 10px solid #F4F4F4;
 *   }
 *   .concrete_character_gap {
 *     cursor: pointer;
 *     display: inline-block;
 *     min-width: 1em;
 *   }
 *   .connected_concrete_characters {
 *     background-color: yellow;
 *     border-bottom: 10px solid #CCCCCC;
 *   }
 * ```
 *
 * Parameters for `options` object:
 * - `charactersInitiallyConnected` (Boolean): Flag
 *   for whether all characters in an *untokenized*
 *   Sentence should be connected.  If the Sentence
 *   already has a Tokenization, then this flag
 *   will be ignored.
 *   Default value: *true*
 * - `toggleConnectionKey` (String): Key used to toggle
 *   the connection between characters.  The string should
 *   be a
 *   {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values
 *    valid KeyboardEvent.key value}.
 *   Please note that Safari/WebKit does not currently
 *   support the KeyboardEvent.key field, so you need
 *   to set the `toggleConnectionKeyCode` option for
 *   these browsers.
 *   Default value: 'x'
 * - `toggleConnectionKeyCode` (Number): KeyCode used to
 *   toggle the connection between characters.  Please
 *   note that KeyCode values are system and implementation
 *   dependent.
 *   Default value: 88 (KeyCode for 'x')
 *
 * @param {Sentence} sentence
 * @param {Object} options
 * @returns {external:jQuery_Object} - this jQuery object
 *
 * @function external:"jQuery.fn".manualTokenizationWidget
 */
$.fn.manualTokenizationWidget = function(sentence, options) {

  // onkeydown event handler for navigating manualTokenizationWidget
  //
  // 'x' key connects/disconnects characters, arrow keys used for
  // navigation.
  //
  // Tab and shift-tab can also be used to navigate, but tab
  // navigation is handled by the browser (using 'tabindex'
  // attributes) instead of this function.
  function manualTokenizationKeyboardNavigation(event) {
    var el = $(this);
    if (el.hasClass('concrete_character_gap')) {
      var characterGapEls;
      var characterGapIndex;

      if (event.key === opts.toggleConnectionKey || event.keyCode === opts.toggleConnectionKeyCode) {
        toggleConnectedCharacters(el);
      }
      else if (event.key === 'ArrowLeft' || event.keyCode === 37) {
        if (el.prev().prev('.concrete_character_gap').length !== 0) {
          // Move cursor to left
          el.prev().prev('.concrete_character_gap').focus();
        }
        else {
          characterGapEls = $('.concrete_character_gap');
          characterGapIndex = characterGapEls.index(el);
          if (characterGapIndex === 0) {
            // Wraparound
            characterGapEls.last().focus();
          }
          else {
            characterGapEls.eq(characterGapIndex-1).focus();
          }
        }
      }
      else if (event.key === 'ArrowRight' || event.keyCode === 39) {
        if (el.next().next('.concrete_character_gap').length !== 0) {
          // Move cursor to right
          el.next().next('.concrete_character_gap').focus();
        }
        else {
          characterGapEls = $('.concrete_character_gap');
          characterGapIndex = characterGapEls.index(el);
          if (characterGapIndex >= characterGapEls.length-1) {
            // Wraparound
            characterGapEls.first().focus();
          }
          else {
            characterGapEls.eq(characterGapIndex+1).focus();
          }
        }
      }
      else if (event.key === 'ArrowUp' || event.keyCode === 38) {
        characterGapEls = $('.concrete_character_gap');
        characterGapIndex = characterGapEls.index(el);
        if (characterGapIndex === 0 ||
            characterGapEls.index(el.siblings('.concrete_character_gap').first()) === 0)
        {
          // Wraparound
          characterGapEls.eq(characterGapEls.length-1).siblings('.concrete_character_gap').first().focus();
        }
        else {
          var firstInSentenceIndex = characterGapEls.index(el.siblings('.concrete_character_gap').first());
          if (characterGapEls.index(el) &lt; firstInSentenceIndex) {
            // All siblings are to right of current element
            characterGapEls.eq(characterGapEls.index(el)-1).siblings('.concrete_character_gap').first().focus();
          }
          else {
            characterGapEls.eq(firstInSentenceIndex-1).siblings('.concrete_character_gap').first().focus();
          }
        }
      }
      else if (event.key === 'ArrowDown' || event.keyCode === 40) {
        characterGapEls = $('.concrete_character_gap');
        var lastInSentence = el.siblings('.concrete_character_gap').last();
        var lastInSentenceIndex = characterGapEls.index(lastInSentence);
        if (lastInSentenceIndex === characterGapEls.length-1) {
          // Wraparound
          characterGapEls.first().focus();
        }
        else {
          if (characterGapEls.index(el) > lastInSentenceIndex) {
            // All siblings are to left of current element
            characterGapEls.eq(characterGapEls.index(el)+1).focus();
          }
          else {
            characterGapEls.eq(lastInSentenceIndex+1).focus();
          }
        }
      }
    }
  }

  /**
   * mousedown event handler.  Toggles connected characters IFF
   * the element already has the focus.
   */
  function mouseToggleConnectedCharacters() {
    var el = $(this);
    if (el.hasClass('concrete_character_gap')) {
      if (el.is(':focus')) {
        toggleConnectedCharacters(el);
      }
    }
  }

  function toggleConnectedCharacters(el) {
    var prevEl = el.prev();
    var nextEl = el.next();

    if (el.hasClass('connected_concrete_characters')) {
      el.removeClass('connected_concrete_characters');
      if (!el.prev().prev('.concrete_character_gap').hasClass('connected_concrete_characters')) {
        prevEl.removeClass('connected_concrete_characters');
      }
      if (!el.next().next('.concrete_character_gap').hasClass('connected_concrete_characters')) {
        nextEl.removeClass('connected_concrete_characters');
      }
    }
    else {
      el.addClass('connected_concrete_characters');
      prevEl.addClass('connected_concrete_characters');
      nextEl.addClass('connected_concrete_characters');
    }
  }


  var opts = $.extend({}, $.fn.manualTokenizationWidget.defaultOptions, options);

  // We do not want any of the .concrete_character_gap spans to have a tabindex of 0, as
  // a tabindex of 0 is treated differently than a tabindex of 1 or greater:
  //   https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
  // We use a positive offset, so that the character in the Communication with
  // character index 0 is not assigned a tabindex of 0.
  var TOKENIZE_TABINDEX_OFFSET = 10;

  var tokenizeSentenceDiv = $('&lt;div>').addClass('manual_tokenization')
                                      .data('sentence', sentence);

  var hasTokenization = !!sentence.tokenization;
  var tokenConnectedCharacters = [];

  if (hasTokenization) {
    for (var j = 0; j &lt; sentence.tokenization.tokenList.tokenList.length; j++) {
      var tokenTextSpan = sentence.tokenization.tokenList.tokenList[j].textSpan;
      if (tokenTextSpan.ending - tokenTextSpan.start > 1) {
        for (var k = tokenTextSpan.start; k &lt; tokenTextSpan.ending-1; k++) {
          tokenConnectedCharacters.push(k);
        }
      }
    }
  }

  for (var i = sentence.textSpan.start; i &lt; sentence.textSpan.ending; i++) {
    var characterSpan = $('&lt;span>').addClass('concrete_character')
                                   .text(sentence.section.comm.text.substring(i, i+1));
    if (hasTokenization) {
      if (tokenConnectedCharacters.includes(i-1) || tokenConnectedCharacters.includes(i)) {
        characterSpan.addClass('connected_concrete_characters');
      }
    }
    else if (opts.charactersInitiallyConnected) {
      characterSpan.addClass('connected_concrete_characters');
    }

    tokenizeSentenceDiv.append(characterSpan);
    if (i &lt; sentence.textSpan.ending-1) {
      var characterGapSpan = $('&lt;span>').addClass('concrete_character_gap')
                                        .attr('tabindex', TOKENIZE_TABINDEX_OFFSET + i)
                                        .data('tokenIndex', i)
                                        .html('&amp;nbsp; ')
                                        .keydown(manualTokenizationKeyboardNavigation)
                                        .mousedown(mouseToggleConnectedCharacters);
      if ((hasTokenization &amp;&amp; tokenConnectedCharacters.includes(i)) ||
          (!hasTokenization &amp;&amp; opts.charactersInitiallyConnected))
      {
        characterGapSpan.addClass('connected_concrete_characters');
      }

      tokenizeSentenceDiv.append(characterGapSpan);
    }
  }
  this.append(tokenizeSentenceDiv);

  return this;
};

$.fn.manualTokenizationWidget.defaultOptions = {
  'charactersInitiallyConnected': true,
  'toggleConnectionKey': 'x',
  'toggleConnectionKeyCode': 88,
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.9</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
